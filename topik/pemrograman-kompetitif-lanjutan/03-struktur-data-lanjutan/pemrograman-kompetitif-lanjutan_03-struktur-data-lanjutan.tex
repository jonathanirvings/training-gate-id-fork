\input{../config.tex}

\title{Struktur Data Lanjutan}
\author{Tim Olimpiade Komputer Indonesia}
\date{}
\lstset{escapeinside={<@}{@>}}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}
\frametitle{Pendahuluan}
Melalui dokumen ini, kalian akan:
\begin{itemize}
  \item Memahami penggunaan C++ set/map
  \item Memahami konsep Fenwick Tree
  \item Memahami konsep Segment Tree
  \item Memahami konsep Sparse Table
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{C++ set}
\begin{itemize}
  \item Pada C++ STL (Standard Template Library), terdapat tipe data \lstinline{std::set<T>} yang dapat digunakan untuk menyimpan sebuah himpunan (\fset) \lstinline{T}.
  \begin{itemize}
    \item Sebagai contoh, \lstinline{set<int>} merupakan himpunan \lstinline{int}.
  \end{itemize}
  \item Untuk menggunakan tipe data ini, kita harus menambahkan \lstinline{include <set>}.
  \item Pada umumnya, \lstinline{set} akan menyimpan objek secara terurut menaik.
  \begin{itemize}
    \item Perilaku ini dapat diubah menggunakan \foreignTerm{custom comparator}. Sebagai contoh, pada C++11:
\begin{lstlisting}
auto cmp = [](int a, int b) { ... };
set<int, decltype(cmp)> s(cmp);
\end{lstlisting}
  \end{itemize}
  \item \lstinline{set} diimplementasikan menggunakan \foreignTerm{self balancing binary tree}\xspace, yang akan dibahas pada beberapa materi selanjutnya.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Operasi C++ set}
\begin{itemize}
  \item Beberapa fungsi/operasi umum yang sering digunakan pada C++ \lstinline{set}.
  \begin{itemize}
    \item \lstinline{set::insert(x)} menambahkan elemen \lstinline{x} pada \lstinline{set} dalam waktu $O(\log N)$.
    \item \lstinline{set::erase(x)} menghapus elemen \lstinline{x} pada \lstinline{set} dalam waktu $O(\log N)$.
    \item \lstinline{set::size()} mengembalikan banyaknya elemen pada \lstinline{set} dalam waktu $O(1)$.
    \item \lstinline{set::count(x)} mengembalikan banyaknya elemen $x$ pada \lstinline{set} dalam waktu $O(\log N)$ (antara $0$ atau $1$).
    \item \lstinline{set::clear()} menghapus seluruh elemen \lstinline{set} dalam waktu $O(N)$.
  \end{itemize}
  dengan $N$ adalah banyaknya elemen pada \lstinline{set}.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Set Iterator}
\begin{itemize}
  \item \lstinline{set<int>::iterator} adalah tipe data penunjuk sebuah elemen pada \lstinline{set}.
  \begin{itemize}
    \item Sebagai contoh, operasi \lstinline{set<int>::iterator it = s.begin();} akan membuat iterator \lstinline{it} menunjuk pada elemen pertama pada himpunan \lstinline{s} (jika \lstinline{s} tidak kosong).
    \item Kemudian operasi \lstinline{it++} akan membuat iterator \lstinline{it} menunjuk pada elemen kedua pada himpunan \lstinline{s} (jika \lstinline{s} berisi setidaknya dua bilangan).
    \item Untuk mendapatkan elemen yang ditunjuk, kita dapat menggunakan \lstinline{*it}.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Set Iterator (lanj.)}
\begin{itemize}
  \item Beberapa fungsi/operasi umum yang sering digunakan pada C++ \lstinline{set} yang mengembalikan \lstinline{set<int>::iterator} dalam waktu $O(\log N)$.
  \begin{itemize}
    \item \lstinline{set::lower_bound(x)} mengembalikan penunjuk elemen terkecil yang tidak lebih kecil dari \lstinline{x} dalam waktu $O(\log N)$. Jika tidak ada elemen yang memenuhi, maka \lstinline{set::lower_bound(x)} akan mengembalikan \lstinline{set::end()}.
    \item \lstinline{set::upper_bound(x)} mengembalikan penunjuk elemen terkecil yang lebih besar dari \lstinline{x} dalam waktu $O(\log N)$. Jika tidak ada elemen yang memenuhi, maka \lstinline{set::upper_bound(x)} akan mengembalikan \lstinline{set::end()}.
    \item \lstinline{set::find(x)} mengembalikan penunjuk elemen yang bernilai \lstinline{x} dalam waktu $O(\log N)$. Jika tidak ada elemen yang memenuhi, maka \lstinline{set::find(x)} akan mengembalikan \lstinline{set::end()}.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Operasi C++ multiset}
\begin{itemize}
  \item C++ \lstinline{std::multiset<T>} merupakan tipe data yang mirip dengan \lstinline{set} namun dapat menyimpan beberapa elemen yang sama.
  \item Beberapa perbedaan antara C++ \lstinline{multiset} dan \lstinline{set}
  \begin{itemize}
    \item \lstinline{multiset::count(x)} dapat mengembalikan bilangan bulat lebih besar dari $1$.
    \item \lstinline{multiset::erase(x)} menghapus seluruh elemen \lstinline{x} pada \lstinline{multiset}. Jika kita ingin menghapus hanya satu elemen \lstinline{x}, gunakan \lstinline{multiset::erase(multiset::find(x))}.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{C++ map}
\begin{itemize}
  \item C++ \lstinline{std::map<K, V>} merupakan tipe data yang digunakan untuk menyimpan pemetaan dari tipe data \lstinline{K} ke tipe data \lstinline{V}.
  \begin{itemize}
    \item Sebagai contoh, \lstinline{map<string, int>} merupakan pemetaan dari \lstinline{string} ke \lstinline{int}.
    \item Contoh penggunaan tipe data ini adalah untuk menyimpan pemetaan dari nama murid ke nilai ujian, dan mengakses nilai ujian seorang murid dalam waktu cepat.
  \end{itemize}
  \item Untuk menggunakan tipe data ini, kita harus menambahkan \lstinline{include <map>}.
  \item \lstinline{map} juga diimplementasikan menggunakan \foreignTerm{self balancing binary tree}\xspace.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Operasi C++ map}
\begin{itemize}
  \item Misalkan kita memiliki \lstinline{map<K, V> myMap;}.
  \item Beberapa fungsi/operasi umum yang sering digunakan pada C++ \lstinline{map}.
  \begin{itemize}
    \item \lstinline{myMap[k]} mengakses nilai pemetaan \lstinline{k} dalam waktu $O(\log N)$.
    \item \lstinline{myMap[k] = v} menentukan atau mengganti pemetaan dari \lstinline{k} menjadi ke \lstinline{v} dalam waktu $O(\log N)$.
    \item \lstinline{myMap.erase(k)} menghapus nilai pemetaan $k$ dalam waktu $O(\log N)$.
    \item \lstinline{myMap.count(k)} mengembalikan $1$ jika terdapat nilai pemetaan $k$, atau $0$ jika tidak, dalam waktu $O(\log N)$.
    \item \lstinline{myMap.clear()} menghapus seluruh pemetaan dalam waktu $O(N)$.
  \end{itemize}
  dengan $N$ adalah banyaknya elemen pada \lstinline{myMap}.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Persoalan Range Sum Query}
\begin{itemize}
  \item Persoalan Range Sum Query adalah persoalan menghitung jumlah elemen berurutan pada sebuah \farray $A$ berukuran $N$.
  \begin{itemize}
    \item Pada umumnya, diberikan $Q$ pertanyaan yang merepresentasikan sebuah \fsubarray.
  \end{itemize}
  \item Jika \farray yang diberikan tidak dapat berubah, persoalan ini dapat diselesaikan menggunakan \fprefixSum yang menjawab satu pertanyaan dalam waktu $O(1)$.
  \item Jika \farray yang diberikan dapat berubah, persoalan ini dapat diselesaikan menggunakan \ffenwickTree yang menjawab satu pertanyaan dalam waktu $O(\log N)$ dan mengganti satu elemen \farray dalam waktu $O(\log N)$.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Fenwick Tree}
\begin{itemize}
  \item \newTerm{Fenwick Tree} (sering disebut juga \newTerm{Binary Indexed Tree}) adalah data struktur yang menyimpan sebuah \farray berukuran $N$ dengan indeks $1$ sampai $N$ dengan setiap elemennya menyimpan jumlah elemen berurutan pada \farray $A$.
  \begin{itemize}
    \item $BIT[j]$ menyimpan jumlah elemen $\sum_{i=j - LSBIT(j) + 1}^{j} A[i]$, dengan $LSBIT(j)$ adalah nilai dari \lstinline{j & (-j)} pada C++. Sebagai contoh,
    \begin{itemize}
      \item $LSBIT(1) = 1, BIT[1] = A[1]$,
      \item $LSBIT(2) = 2, BIT[2] = A[1] + A[2]$,
      \item $LSBIT(3) = 1, BIT[3] = A[3]$,
      \item $LSBIT(4) = 4, BIT[4] = A[1] + A[2] + A[3] + A[4]$, dan
      \item $LSBIT(6) = 2, BIT[6] = A[5] + A[6]$.
    \end{itemize}
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Fenwick Tree (lanj.)}
\begin{itemize}
  \item Dengan \ffenwickTree, kita dapat menghitung nilai $\sum_{i=1}^{x} A[i]$ dalam $O(\log N)$.
  \begin{itemize}
    \item Sebagai contoh, menghitung nilai $A[1] + A[2] + A[3] + A[4] + A[5] + A[6]$ dapat disederhanakan menjadi $(A[1] + A[2] + A[3] + A[4]) + (A[5] + A[6]) = BIT[4] + BIT[6]$.
  \end{itemize}
  \item Secara umum, $\sum_{i=1}^{x}$ dapat dihitung menggunakan rumus berikut:
  \begin{itemize}
    \item $0$, jika $x = 0$,
    \item $BIT[x] + \sum_{i=1}^{x - LSBIT(x)}$, jika $x > 0$.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Fenwick Tree (lanj.)}
\begin{itemize}
  \item Jika nilai $A[i]$ berubah, maka kita harus memperbaharui semua nilai $BIT[j]$ yang memenuhi $j - LSBIT(j) < i \leq j$. Terdapat $O(\log N)$ nilai yang harus diperbaharui.
  \begin{itemize}
    \item Sebagai contoh, jika nilai $A[5]$ berubah, maka kita harus memperbaharui nilai $BIT[5], BIT[6], BIT[8], BIT[16], \cdots$.
  \end{itemize}
  \item Secara umum, jika nilai $A[i]$ berubah menjadi $A[i] + \delta$, kita dapat memanggil fungsi \lstinline{update(i)} yang melakukan hal berikut jika $i \leq N$:
  \begin{itemize}
    \item Perbaharui nilai $BIT[i]$ menjadi $BIT[i] + \delta$.
    \item Panggil fungsi \lstinline{update(i + LSBIT(i)}.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Segment Tree}
\begin{itemize}
  \item Segment Tree merupakan struktur data alternatif untuk menyelesaikan persoalan Range Sum Query.
  \item Segment Tree merupakan pohon biner (binary tree). Tiap node memiliki informasi nilai dari suatu rentang atau segmen. Ukuran segmen dari suatu node pada segment tree merupakan gabungan segmen dari anak-anaknya.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Ilustrasi Segment Tree}
\begin{itemize}
  \item Misalkan kita memiliki array berukuran N. Segment Tree dari array tersebut memiliki log N tingkat, masing-masing tingkat merepresentasikan segmen berukuran $2^l$. 
  \item Secara keseluruhan, terdapat maksimal 2*N segmen. Kompleksitas memori dari Segment Tree ialah O(N).
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Ilustrasi Segment Tree (lanj.)}
\begin{itemize}
  \item Sebagai contoh, berikut merupakan bentuk segment tree untuk menghitung range sum query dari array $[5, -3, 2, 1, 4, 4, -1, 6]$.
  \item Tiap node memiliki informasi sum dari segmen yang dilingkupinya.
\end{itemize}
\begin{center}
  \includegraphics[width=10cm]{asset/segtree-init.png}
\end{center}
\end{frame}

\begin{frame}[fragile]
\frametitle{Inisiasi Segment Tree}
\begin{itemize}
  \item Berikut adalah contoh kode untuk menginisiasi segment tree untuk menghitung range sum query.
\begin{lstlisting}
int st[MAXA];         // informasi segment sum

void build(int idx, int l, int r) {
  if (l == r) {
    st[idx] = val[l];
    return;
  }

  int mid = (l + r) / 2;
  build(idx * 2 + 1, l, mid); // rekursif ke kiri
  build(idx * 2 + 2, mid + 1, r); // rekursif ke kanan
  
  st[idx] = st[lc] + st[rc];
}

...
bulid(1, 0, N); // pemanggilan awal
\end{lstlisting}
\end{itemize}
\end{frame}



\begin{frame}
\frametitle{Query pada Segment Tree}
\begin{itemize}
  \item Untuk mendapatkan sum dari interval L sampai R, kita cukup menjumlahkan segmen-segmen yang membentuk interval L sampai R.
  \item Kompleksitas untuk tiap query adalah O(log N).
\end{itemize}
\begin{center}
  \includegraphics[width=10cm]{asset/segtree-sum.png}
\end{center}
\end{frame}

\begin{frame}[fragile]
\frametitle{Kode Query pada Segment Tree}
\begin{itemize}
  \item Query dapat dicapai dengan melakukan penjelajahan segment tree dari segmen terbesar, dan berhenti ketika kita berada di segmen yang sepenuhnya overlap dengan range yang ingin dijumlahkan.
  \begin{lstlisting}
int query(int idx, int l, int r, int x, int y) {
  if (x > r || y < l)
    // this node is outside the range
    return 0;

  if (x <= l && r <= y)
    // fully overlap node
    return st[idx];
  
  int mid = (l + r) / 2;
  return query(idx * 2 + 1, l, mid, x, y) + 
         query(idx * 2 + 2, mid + 1, r, x, y);
}
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Single Point Update pada Segment Tree}
\begin{itemize}
  \item Untuk mengupdate nilai elemen di suatu indeks, kita cukup melakukan udpdate di seluruh segmen yang melingkupi indeks tersebut.
  \item Kompleksitas untuk tiap update adalah O(log N).
\end{itemize}
\begin{center}
  \includegraphics[width=10cm]{asset/segtree-update.png}
\end{center}
\end{frame}

\begin{frame}[fragile]
\frametitle{Kode Single Point Update}
\begin{itemize}
  \item Berikut adalah contoh koe jika Anda ingin menambahkan value v pada suatu index x
  \begin{lstlisting}
void update(int idx, int l, int r, int x, int v) {
  // update the sum of values in this range
  st[idx] += v;     

  if (l == r) 
    // leaf node
    return;

  // traverse the correct child
  int mid = (l + r) / 2;
  if (x <= mid) 
    update(idx * 2 + 1, l, mid, x, v);
  else 
    update(idx * 2 + 2, mid + 1, r, x, v);
}
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Range Update pada Segment Tree}
\begin{itemize}
  \item Bagaimana jika kita harus mengupdate beberapa elemen sekaligus dalam suatu range?
  \item Misalnya, untuk suatu range [A,B], tambahkan nilainya dengan v.
  \item Kita bisa melakukan penjelajahan pada segment tree, dan berhenti di leaf yang termasuk dari range.
  \item Namun, kasus terburuknya adalah jika kita harus mengupdate keseluruhan range, sehingga kita harus mengupdate keseluruhan segment tree, yaitu O(N).
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Lazy Propagation}
\begin{itemize}
  \item Agar bisa melakukan range update dengan lebih efisien, kita cukup bisa berhenti pada segmen yang sudah sepenuhnya overlap dengan range yang ingin diupdate.
  \item Karena kita berhenti di segmen X, kita sebenarnya belum mengupdate informasi pada segmen-segmen yang merupakan anak dari X.
  \item Karena itu, kita perlu menyiapkan informasi tambahan yang menyatakan update yang belum terselesaikan. Informasi ini akan dipropagasi nanti ketika kita melakukan penjelajahan di segmen tersebut.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Ilustrasi Lazy Propagation}
\begin{itemize}
  \item Berikut adalah ilustrasi dari lazy propagation untuk melakukan range update.
\end{itemize}
\begin{center}
  \includegraphics[width=10cm]{asset/segtree-update-lazy.png}
\end{center}
\end{frame}

\begin{frame}[fragile]
\frametitle{Kode Lazy Propagation}
\begin{itemize}
  \item Berikut adalah kode untuk melakukan lazy propagation.
\end{itemize}
  \begin{lstlisting}
void update(int idx, int l, int r, int x, int y, int v) {
  if (x < r || l > y) return; // stop if outside the range
  if (x <= l && r <= y) {
    // update the sum for this range
    st[idx] += (r - l + 1) * v;     
    // update the lazy value for this range
    lazy[idx] += v;                 
    return;
  }
  
  int mid = (l + r)/2, lc = idx * 2 +1, rc = idx * 2 +2;

  propagate(idx, l, r);

  update(lc, l, mid, x, y, v);    // check the left child
  update(rc, mid + 1, r, x, y, v);// check the right child
  
  st[idx] = st[lc] + st[rc];      // range update
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Kode Propagasi}
\begin{itemize}
  \item Fungsi tambahan propagate adalah untuk meneruskan update yang belum dieksekusi ke anak segmen.
\end{itemize}
  \begin{lstlisting}
void propagate(int idx, int l, int r) {
  // hanya perlu dilakukan jika nilai lazy tidak 0
  if (lazy[idx]) { 
    int mid = (l + r)/2, lc = idx * 2 +1, rc = idx * 2 +2;
    // propagate to left child
    lazy[lc] += lazy[idx]; st[lc] += (mid - l + 1) * lazy[idx]; 
    // propagate to right child
    lazy[rc] += lazy[idx]; st[rc] += (r - mid) * lazy[idx];

    lazy[idx] = 0; // clear the lazy value
  }
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Query dengan Lazy Propagation}
\begin{itemize}
  \item Query pada segment-tree yang mengandung lazy propagation persis pada query biasa, hanya saja cukup ditambahkan fungsi propagasi sebagai berikut.
  \begin{lstlisting}
int query(int idx, int l, int r, int x, int y) {
  if (x > r || y < l)
    // this node is outside the range
    return 0;

  if (x <= l && r <= y)
    // fully overlap node
    return st[idx];

  <@\textcolor{red}{propagate(idx, l, r);}@>
  
  int mid = (l + r) / 2;
  return query(idx * 2 + 1, l, mid, x, y) + 
         query(idx * 2 + 2, mid + 1, r, x, y);
}
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Sparse Table}
\begin{itemize}
  \item TBA
\end{itemize}
\end{frame}

\end{document}
